//
//  AppAttestService.swift
//  Aptos Passport KYC
//
//  Created by Harold on 2025/7/18.
//

import Foundation
import DeviceCheck
import Combine
import CryptoKit

@MainActor
class AppAttestService: ObservableObject {
    static let shared = AppAttestService()
    
    @Published var isLoading: Bool = false
    @Published var errorMessage: String?
    @Published var lastKeyId: String?
    @Published var lastAttestation: Data?
    
    private init() {
        // Remove state restoration during initialization to avoid circular dependencies
    }
    
    // MARK: - Public Methods
    
    func checkAppAttestSupport() -> Bool {
        let isSupported = DCAppAttestService.shared.isSupported
        print("ğŸ“± Device App Attest Support: \(isSupported)")
        
        #if targetEnvironment(simulator)
        print("âš ï¸  Running on iOS Simulator - App Attest may not work properly")
        #endif
        
        return isSupported
    }
    
    func performAttestation() async throws -> (keyId: String, attestation: Data) {
        guard checkAppAttestSupport() else {
            throw IntegrityError.appAttestNotSupported
        }
        
        isLoading = true
        errorMessage = nil
        
        do {
            print("ğŸ”„ ========== App Attest Process Started ==========")
            print("ğŸ“‹ Stage 1: Device Registration (App Attest)")
            
            // Step 1: Generate key pair (key pair generation)
            print("ğŸ“ Step 1: Generate device key pair...")
            let keyId = try await DCAppAttestService.shared.generateKey()
            print("âœ… Key pair generated successfully!")
            print("ğŸ”‘ Key ID: \(keyId)")
            print("ğŸ” Private key securely stored in device secure enclave (Secure Enclave)")
            print("ğŸ”“ Public key will be included in certificate and sent to server")
            
            // Step 2: Simulate server challenge data (generated by server in real application)
            print("\nğŸ“¥ Step 2: Receive server challenge data...")
            print("âš ï¸  POCæ¨¡å¼: ä½¿ç”¨ç¡¬ç¼–ç æŒ‘æˆ˜æ•°æ®")
            print("ğŸ’¡ å®é™…åº”ç”¨ä¸­: å®¢æˆ·ç«¯ä»æœåŠ¡å™¨è·å–éšæœºæŒ‘æˆ˜æ•°æ®")
            let serverChallenge = "aptos-passport-kyc-demo-challenge".data(using: .utf8)!
            print("ğŸŒ æœåŠ¡å™¨æŒ‘æˆ˜æ•°æ®: \(String(data: serverChallenge, encoding: .utf8) ?? "N/A")")
            print("ğŸ“¦ æŒ‘æˆ˜æ•°æ® (Base64): \(serverChallenge.base64EncodedString())")
            
            // Step 3: å¯¹æŒ‘æˆ˜æ•°æ®è¿›è¡Œå“ˆå¸Œå¤„ç†
            print("\nğŸ”’ æ­¥éª¤3: å¤„ç†æŒ‘æˆ˜æ•°æ®...")
            let clientDataHash = SHA256.hash(data: serverChallenge)
            let clientDataHashData = Data(clientDataHash)
            print("ï¿½ SHA256å“ˆå¸Œ: \(clientDataHashData.base64EncodedString())")
            print("ğŸ’¡ Appleè¦æ±‚å¯¹æŒ‘æˆ˜æ•°æ®è¿›è¡ŒSHA256å“ˆå¸Œ")
            
            // Step 4: åˆ›å»ºè¯ä¹¦
            print("\nğŸ“œ æ­¥éª¤4: åˆ›å»ºApp Attestè¯ä¹¦...")
            print("ï¿½ è°ƒç”¨Appleçš„attestKey API...")
            let attestation = try await DCAppAttestService.shared.attestKey(keyId, clientDataHash: clientDataHashData)
            
            // Store for user access
            lastKeyId = keyId
            lastAttestation = attestation
            
            // è®°å½•è®¤è¯çŠ¶æ€åˆ°AuthenticationStateManager
            AuthenticationStateManager.shared.recordAuthentication(keyId: keyId)
            
            print("âœ… è¯ä¹¦åˆ›å»ºæˆåŠŸ!")
            print("ğŸ“‹ è¯ä¹¦ä¿¡æ¯:")
            print("   - Key ID: \(keyId)")
            print("   - è¯ä¹¦å¤§å°: \(attestation.count) bytes")
            print("   - æ ¼å¼: CBOR (Concise Binary Object Representation)")
            print("   - åŒ…å«å†…å®¹: è®¾å¤‡è¯ä¹¦é“¾ + åº”ç”¨ID + å…¬é’¥ + æŒ‘æˆ˜å“ˆå¸Œ")
            
            print("\nğŸš€ æ­¥éª¤5: å‡†å¤‡å‘é€ç»™æœåŠ¡å™¨...")
            print("ğŸ“¤ æ¥ä¸‹æ¥åº”è¯¥å°†æ­¤è¯ä¹¦å‘é€ç»™æœåŠ¡å™¨è¿›è¡ŒéªŒè¯")
            print("ğŸ” æœåŠ¡å™¨éªŒè¯æµç¨‹:")
            print("   1. éªŒè¯è¯ä¹¦ç­¾å (ç”±Appleç­¾å)")
            print("   2. æ£€æŸ¥åº”ç”¨Bundle ID")
            print("   3. éªŒè¯æŒ‘æˆ˜æ•°æ®")
            print("   4. æå–å¹¶ä¿å­˜å…¬é’¥")
            print("   5. å®Œæˆè®¾å¤‡æ³¨å†Œ")
            
            print("ğŸ¯ ========== App Attest æµç¨‹å®Œæˆ ==========\n")
            
            isLoading = false
            return (keyId: keyId, attestation: attestation)
            
        } catch {
            isLoading = false
            let detailedError = "App Attest failed: \(error.localizedDescription)"
            print("âŒ App Attest å¤±è´¥: \(detailedError)")
            
            // Check for common errors
            if let dcError = error as? DCError {
                switch dcError.code {
                case .featureUnsupported:
                    errorMessage = "è®¾å¤‡ä¸æ”¯æŒ App Attest"
                    print("âŒ é”™è¯¯åŸå› : è®¾å¤‡ä¸æ”¯æŒApp AtteståŠŸèƒ½")
                case .invalidInput:
                    errorMessage = "æ— æ•ˆçš„æŒ‘æˆ˜æ•°æ®æ ¼å¼"
                    print("âŒ é”™è¯¯åŸå› : æŒ‘æˆ˜æ•°æ®æ ¼å¼æ— æ•ˆ")
                case .invalidKey:
                    errorMessage = "å¯†é’¥ç”Ÿæˆå¤±è´¥"
                    print("âŒ é”™è¯¯åŸå› : è®¾å¤‡å¯†é’¥ç”Ÿæˆå¤±è´¥")
                case .serverUnavailable:
                    errorMessage = "AppleæœåŠ¡ä¸å¯ç”¨"
                    print("âŒ é”™è¯¯åŸå› : Appleçš„App AttestæœåŠ¡æš‚æ—¶ä¸å¯ç”¨")
                default:
                    errorMessage = "App Attest é”™è¯¯: \(dcError.localizedDescription)"
                    print("âŒ é”™è¯¯åŸå› : \(dcError.localizedDescription)")
                }
            } else {
                errorMessage = detailedError
            }
            
            throw IntegrityError.attestationFailed
        }
    }
    
    func saveCertificateToFile(attestation: Data, keyId: String) -> String {
        let formatter = DateFormatter()
        formatter.dateFormat = "yyyy-MM-dd HH:mm:ss"
        let dateString = formatter.string(from: Date())
        
        let certificateContent = """
        {
            "app_attest_certificate": {
                "generated_at": "\(dateString)",
                "key_id": "\(keyId)",
                "bundle_id": "\(Bundle.main.bundleIdentifier ?? "unknown")",
                "attestation_base64": "\(attestation.base64EncodedString())",
                "attestation_size": \(attestation.count),
                "format": "CBOR",
                "description": "Apple App Attest Certificate for Aptos Passport KYC POC",
                "flow_info": {
                    "stage": "ç¬¬ä¸€é˜¶æ®µï¼šè®¾å¤‡æ³¨å†Œï¼ˆApp Attestï¼‰",
                    "purpose": "å‘æœåŠ¡å™¨è¯æ˜è®¾å¤‡å’Œåº”ç”¨çš„å®Œæ•´æ€§",
                    "contains": [
                        "è®¾å¤‡è¯ä¹¦é“¾ï¼ˆç”±Appleç­¾åï¼‰",
                        "åº”ç”¨Bundle ID",
                        "è®¾å¤‡ç”Ÿæˆçš„å…¬é’¥",
                        "æŒ‘æˆ˜æ•°æ®çš„å“ˆå¸Œå€¼"
                    ]
                },
                "server_verification_steps": [
                    "1. éªŒè¯è¯ä¹¦æ˜¯å¦ç”±Appleç­¾å",
                    "2. æ£€æŸ¥Bundle IDæ˜¯å¦åŒ¹é…",
                    "3. éªŒè¯æŒ‘æˆ˜æ•°æ®å“ˆå¸Œ",
                    "4. æå–å…¬é’¥å¹¶ä¿å­˜",
                    "5. æ ‡è®°è®¾å¤‡ä¸ºå·²è®¤è¯"
                ],
                "next_phase": {
                    "name": "ç¬¬äºŒé˜¶æ®µï¼šåç»­é€šä¿¡ï¼ˆApp Assertï¼‰",
                    "description": "ä½¿ç”¨æ­¤å¯†é’¥å¯¹åç»­æ•æ„Ÿæ•°æ®è¿›è¡Œç­¾åéªŒè¯"
                },
                "poc_note": "æ­¤ä¸ºPOCæ¼”ç¤ºï¼Œå®é™…åº”ç”¨ä¸­æŒ‘æˆ˜æ•°æ®åº”ç”±æœåŠ¡å™¨ç”Ÿæˆ"
            }
        }
        """
        
        return certificateContent
    }
    
    // MARK: - Attestation Verification (for future use)
    
    func generateAssertion(keyId: String, clientDataHash: Data) async throws -> Data {
        print("ğŸ”„ ========== App Assert æµç¨‹å¼€å§‹ ==========")
        print("ğŸ“‹ ç¬¬äºŒé˜¶æ®µï¼šåç»­é€šä¿¡ï¼ˆApp Assertï¼‰")
        print("ğŸ”‘ ä½¿ç”¨å·²è®¤è¯çš„Key ID: \(keyId)")
        print("ğŸ“¦ æ¶ˆæ¯æ•°æ®å“ˆå¸Œ: \(clientDataHash.base64EncodedString())")
        
        // This method generates an assertion using an existing attested key
        // Useful for ongoing verification after initial attestation
        do {
            print("ğŸ” ä½¿ç”¨è®¾å¤‡ç§é’¥å¯¹æ¶ˆæ¯è¿›è¡Œç­¾å...")
            let assertion = try await DCAppAttestService.shared.generateAssertion(keyId, clientDataHash: clientDataHash)
            print("âœ… ç­¾åç”ŸæˆæˆåŠŸ!")
            print("ğŸ“‹ ç­¾åä¿¡æ¯:")
            print("   - ç­¾åå¤§å°: \(assertion.count) bytes")
            print("   - ç­¾åç®—æ³•: ä½¿ç”¨è®¾å¤‡ç§é’¥ï¼ˆECDSAï¼‰")
            print("   - åŒ…å«å†…å®¹: æ¶ˆæ¯ç­¾å + è®¡æ•°å™¨ + æ—¶é—´æˆ³")
            
            print("ğŸš€ å‡†å¤‡å‘é€ç»™æœåŠ¡å™¨...")
            print("ğŸ“¤ æœåŠ¡å™¨éªŒè¯æµç¨‹:")
            print("   1. ä½¿ç”¨ä¿å­˜çš„å…¬é’¥éªŒè¯ç­¾å")
            print("   2. æ£€æŸ¥è®¡æ•°å™¨é€’å¢ï¼ˆé˜²é‡æ”¾æ”»å‡»ï¼‰")
            print("   3. éªŒè¯æ—¶é—´æˆ³æœ‰æ•ˆæ€§")
            print("   4. ç¡®è®¤æ¶ˆæ¯å®Œæ•´æ€§")
            print("ğŸ¯ ========== App Assert æµç¨‹å®Œæˆ ==========\n")
            
            return assertion
        } catch {
            print("âŒ App Assert å¤±è´¥: \(error.localizedDescription)")
            throw error
        }
    }
}